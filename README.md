הסבר על ה-Microservices והטופיקים (Topics):

UserInterface (Gateway): הוא ה"שער" של המערכת. הוא מקבל את ההודעה מהאתר ושולח אותה לקפקא. בסוף הוא גם זה שמחזיר את התשובה למשתמש.

מדבר עם: user-input-events (שליחה), bot-responses (קבלה).

RouterService: הוא ה"ממיין". הוא לוקח את הודעת המשתמש, משתמש ב-OpenAI כדי להבין מה המשתמש רוצה (מתמטיקה, מזג אוויר וכו') ושולח את ה"כוונה" הזו הלאה.

מדבר עם: user-input-events (קבלה), router-intents (שליחה).

MemoryService: זה הזיכרון של המערכת. הוא קורא קובץ בשם history.json ומזריק את השיחות הקודמות להודעה כדי שהבוט יזכור על מה דיברנו קודם.

מדבר עם: router-intents (קבלה), router-intents-enriched (שליחה של ההודעה עם הזיכרון).

Worker Apps (Math, Weather, Exchange, General): אלו ה"מומחים". כל אחד יודע לעשות דבר אחד: לחשב, לבדוק מזג אוויר או לענות בצ'אט חופשי. הם פועלים רק כשהם רואים הודעה שמתאימה להם.

מדברים עם: router-intents-enriched (קבלה), app-results (שליחה של התוצאה).

ResponseAggregator: הוא ה"מרכזן". הוא אוסף את התוצאה הגולמית מה-Workers, הופך אותה לטקסט יפה ונוח לקריאה ושולח חזרה ל-UI.

מדבר עם: app-results (קבלה), bot-responses (שליחה).

ResetService: שירות קטן שתפקידו לאפס את השיחה. כשהוא מזהה פקודת איפוס, הוא דואג למחוק את ההיסטוריה.

מדבר עם: user-control-events (קבלה).

ארכיטקטורת המערכת:

הלקוח (React) שולח הודעה לשרת ה-Express. השרת שולח אותה לצינור (Topic) בקפקא. משם ההודעה עוברת בשרשרת: Router (מיון) -> Memory (הוספת זיכרון) -> Worker (ביצוע הפעולה) -> Aggregator (עיצוב התשובה) -> ובחזרה לשרת וללקוח. הכל עובר דרך קפקא בצורה מבוזרת.

אתגרים שנתקלנו בהם:

סנכרון: בקפקא התשובה לא חוזרת מיד. היינו צריכים להשתמש ב-Correlation ID (מספר מעקב) כדי שהשרת ידע לשייך כל תשובה למשתמש הנכון.

זיכרון מבוזר: בגלל שהכל מופרד, שירות אחד לא יודע מה השני עשה. פתרנו את זה על ידי שירות זיכרון ייעודי שמעביר את ההיסטוריה בתוך הצינורות של קפקא.

חיבור ראשוני: לפעמים השירותים עלו מהר יותר מהקפקא בדוקר. פתרנו את זה בעזרת מנגנון של ניסיונות חיבור חוזרים (Retry) בקוד.
